# Mpx2.8 版本发布，使用组合式 API 开发小程序

> 作者：[董宏平（hiyuki）](https://github.com/hiyuki)

继年初我们在 2.7 版本中对 [Mpx](https://www.mpxjs.cn/) 的编译系统进行重构支持持久化构建缓存大幅提速后，在最新的 2.8 版本中，我们对 Mpx 的运行时框架也进行了大量重构改造工作，完整支持了 Vue3 提出的组合式 API 开发范式，让用户能够使用当下最热门的开发方式进行小程序开发，我们先来简单感受一下组合式 API 的使用：

```html
<template>
  <view>{{ collectionName }}: {{ book.title }}({{ readersNumber }})</view>
  <button bindtap="addReaders">addReaders</button>
</template>

<script>
  import { createComponent, ref, reactive, onMounted } from '@mpxjs/core'

  createComponent({
    properties: {
      collectionName: String
    },
    setup () {
      const readersNumber = ref(0)
      const book = reactive({ title: 'Mpx' })

      onMounted(() => {
        console.log('Component mounted.')
      })

      // 暴露给 template
      return {
        readersNumber,
        book,
        addReaders () {
          readersNumber.value++
        }
      }
    }
  })
</script>
```

可以看出和 Vue3 组合式 API 的使用是高度类似的，利用框架导出的一系列响应式 API 和 生命周期钩子函数在 `setup` 中编写业务逻辑，并将模板依赖的数据与方法作为返回值返回，与传统的选项式 API 相比，组合式 API 具备以下优势：

* 更好的逻辑复用，通过函数包装复用逻辑，显式引入调用，方便简洁且符合直觉，规避消除了 mixins 复用中存在的缺陷；
* 更灵活的代码组织，相比于选项式 API 提前规定了代码的组织方式，组合式 API 在这方面几乎没有做任何限制与规定，更加灵活自由，在功能复杂的庞大组件中，我们能够通过组合式 API 让我们的功能代码更加内聚且有条理，不过这也会对开发者自身的代码规范意识提出更高要求；
* 更好的类型推导，虽然基于 `this` 的选项式 API 通过 `ThisType` 也能在一定程度上实现 TS 类型推导，但推导和实现成本较高，同时仍然无法完美覆盖一些复杂场景（如嵌套 mixins 等）；而组合式 API 以本地变量和函数为基础，本身就是类型友好的，我们在类型方面几乎不需要做什么额外的工作就能享受到完美的类型推导。

同时与 React Hooks 相比，组合式 API 中的 `setup` 函数只在初始化时单次执行，在数据响应能力的加持下大大降低了理解与使用成本，基于以上原因，我们决定为 Mpx 添加组合式 API 能力，让用户能够用组合式 API 方式进行小程序开发。

## 组合式 API 实现

从上面的简单示例中可以看出，抛开响应式 API 和生命周期注册模式的变化，组合式 API 的实现要点在于动态添加模板依赖的数据和方法，这也是我们在小程序中实现组合式 API 可能遇到的核心技术卡点。

对于动态添加模板依赖数据，我们在过去的实践中已经充分证明了其可行性，事实上，从 Mpx 最初的版本开始，我们就充分利用了这项能力来实现我们的计算属性和 `dataFn` （类似于 Vue 使用函数定义 `data`）的支持，这项能力的关键在于存在一个合适的生命周期用于动态添加初始化数据，这里对于初始化数据的定义是能够影响组件树的初始渲染，举个简单的例子：存在一对父子组件 parent/child，parent 使用 `props` 向 child 传递数据，当我们在 parent 初始创建时使用动态添加数据的方式定义 `props` 数据，而 child 也在初始创建时能够通过 `props` 正确获取到这部分的数据时，那我们认为这部分动态添加的数据就等同于初始化数据，这也是我们在小程序中实现完备数据响应支持的基础（如果无法在子组件初始创建时获取父组件动态添加的数据，动态添加数据的行为会触发子组件 `props` 的更新，从而触发子组件相关 `watcher` 的执行，这些行为对于用户和系统都是非预期的，我们无法在此之上正确编写业务逻辑）。

幸运的是，目前业内所有主流小程序平台（微信/支付宝/百度/字节/QQ）都支持了上述能力，微信从一开始就支持在 `attached` 生命周期中调用 `setData` 函数动态添加初始化数据，在上述的父子 `props` 传递场景中，也能够在子组件的 `attached` 中正确获取这部分数据，支付宝和字节小程序一开始并不支持该能力，不过支付宝在 `component2` 组件系统重构后，字节在橙心合作项目中与我们沟通后，都成功支持了该能力。

而对于动态返回的方法，最简单想到的方案就是直接挂载到组件实例上，经过我们的完整测试，上述业内主流小程序平台都支持使用这种方式动态添加方法，基于以上事实，我们非常确定组合式 API 能够在小程序环境中顺利实现，下图简要展示了小程序中组合式 API 的大致实现流程：



 


### 生命周期钩子函数

在组合式 API 中，`setup` 函数只有在组件创建时初始化单次执行，因此需要提供一系列生命周期钩子函数来代替选项式 API 中的生命周期钩子选项，由于小程序原生只支持选项式的生命周期注册方式，我们通过`预注册-驱动`的方式来实现 `setup` 中函数式注册生命周期钩子的语法糖，简单来讲就是使用选项式的方式提前注册所有需要的生命周期钩子，在选项式生命周期钩子执行时驱动对应在 `setup` 中使用生命周期钩子函数注册的代码逻辑的执行，简要流程如下图所示：

跨平台生命周期钩子

### 组合式 API 与 Vue3 中的差异




## 响应式 API 实现

## 生态周边适配

## 跨平台适配

## 性能表现

## 破坏性改变

## 未来规划

